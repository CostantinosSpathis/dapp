{"ast":null,"code":"//filter will reemit the data if cb(err,pass) pass is truthy\n// reduce is more tricky\n// maybe we want to group the reductions or emit progress updates occasionally\n// the most basic reduce just emits one 'data' event after it has recieved 'end'\nvar through = require('through');\n\nvar Decoder = require('string_decoder').StringDecoder;\n\nmodule.exports = split; //TODO pass in a function to map across the lines.\n\nfunction split(matcher, mapper, options) {\n  var decoder = new Decoder();\n  var soFar = '';\n  var maxLength = options && options.maxLength;\n  if ('function' === typeof matcher) mapper = matcher, matcher = null;\n  if (!matcher) matcher = /\\r?\\n/;\n\n  function emit(stream, piece) {\n    if (mapper) {\n      try {\n        piece = mapper(piece);\n      } catch (err) {\n        return stream.emit('error', err);\n      }\n\n      if ('undefined' !== typeof piece) stream.queue(piece);\n    } else stream.queue(piece);\n  }\n\n  function next(stream, buffer) {\n    var pieces = ((soFar != null ? soFar : '') + buffer).split(matcher);\n    soFar = pieces.pop();\n    if (maxLength && soFar.length > maxLength) stream.emit('error', new Error('maximum buffer reached'));\n\n    for (var i = 0; i < pieces.length; i++) {\n      var piece = pieces[i];\n      emit(stream, piece);\n    }\n  }\n\n  return through(function (b) {\n    next(this, decoder.write(b));\n  }, function () {\n    if (decoder.end) next(this, decoder.end());\n    if (soFar != null) emit(this, soFar);\n    this.queue(null);\n  });\n}","map":null,"metadata":{},"sourceType":"script"}