{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { KeyboardEvent } from 'react';\nimport { UpdateActions } from './enums';\nimport EventBus from './EventBus';\n\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n\nexport interface Column<TRow, TSummaryRow = unknown> {\n  /** The name of the column. By default it will be displayed in the header cell */\n  name: string;\n  /** A unique key to distinguish each column */\n  key: string;\n  /** Column width. If not specified, it will be determined automatically based on grid width and specified widths of other columns */\n  width?: number | string;\n  /** Minimum column width in px. */\n  minWidth?: number;\n  /** Maximum column width in px. */\n  maxWidth?: number;\n  cellClass?: string | ((row: TRow) => string | undefined);\n  headerCellClass?: string;\n  summaryCellClass?: string | ((row: TSummaryRow) => string);\n  /** Formatter to be used to render the cell content */\n  formatter?: React.ComponentType<FormatterProps<TRow, TSummaryRow>>;\n  /** Formatter to be used to render the summary cell content */\n  summaryFormatter?: React.ComponentType<SummaryFormatterProps<TSummaryRow, TRow>>;\n  /** Formatter to be used to render the group cell content */\n  groupFormatter?: React.ComponentType<GroupFormatterProps<TRow, TSummaryRow>>;\n  /** Enables cell editing. If set and no editor property specified, then a textinput will be used as the cell editor */\n  editable?: boolean | ((row: TRow) => boolean);\n  /** Determines whether column is frozen or not */\n  frozen?: boolean;\n  /** Enable resizing of a column */\n  resizable?: boolean;\n  /** Enable sorting of a column */\n  sortable?: boolean;\n  /** Sets the column sort order to be descending instead of ascending the first time the column is sorted */\n  sortDescendingFirst?: boolean;\n  /** Editor to be rendered when cell of column is being edited. If set, then the column is automatically set to be editable */\n  editor?: React.ComponentType<EditorProps<TRow[keyof TRow], TRow, TSummaryRow>>;\n  editor2?: React.ComponentType<Editor2Props<TRow, TSummaryRow>>;\n  editorOptions?: {\n    /** Default: true for editor1 and false for editor2 */\n    createPortal?: boolean;\n    /** Default: false */\n    editOnClick?: boolean;\n    /** Prevent default to cancel editing */\n    onCellKeyDown?: (event: React.KeyboardEvent<HTMLDivElement>) => void;\n    // TODO: Do we need these options\n    // editOnDoubleClick?: boolean;\n    /** Default: true for editor1 and false for editor2 */\n    // commitOnScroll?: boolean;\n  };\n  /** Header renderer for each header cell */\n  headerRenderer?: React.ComponentType<HeaderRendererProps<TRow, TSummaryRow>>;\n  /** Component to be used to filter the data of the column */\n  filterRenderer?: React.ComponentType<FilterRendererProps<TRow, any, TSummaryRow>>;\n}\n\nexport interface CalculatedColumn<TRow, TSummaryRow = unknown> extends Column<TRow, TSummaryRow> {\n  idx: number;\n  width: number;\n  left: number;\n  resizable: boolean;\n  sortable: boolean;\n  isLastFrozenColumn?: boolean;\n  rowGroup?: boolean;\n  formatter: React.ComponentType<FormatterProps<TRow, TSummaryRow>>;\n}\n\nexport interface Position {\n  idx: number;\n  rowIdx: number;\n}\n\nexport interface Editor<TValue = never> {\n  getInputNode: () => Element | Text | undefined | null;\n  getValue: () => TValue;\n  hasResults?: () => boolean;\n  isSelectOpen?: () => boolean;\n  validate?: (value: unknown) => boolean;\n  readonly disableContainerStyles?: boolean;\n}\n\nexport interface FormatterProps<TRow = any, TSummaryRow = any> {\n  rowIdx: number;\n  column: CalculatedColumn<TRow, TSummaryRow>;\n  row: TRow;\n  isCellSelected: boolean;\n  isRowSelected: boolean;\n  onRowSelectionChange: (checked: boolean, isShiftClick: boolean) => void;\n}\n\nexport interface SummaryFormatterProps<TSummaryRow, TRow = any> {\n  column: CalculatedColumn<TRow, TSummaryRow>;\n  row: TSummaryRow;\n}\n\nexport interface GroupFormatterProps<TRow, TSummaryRow = unknown> {\n  groupKey: unknown;\n  column: CalculatedColumn<TRow, TSummaryRow>;\n  childRows: readonly TRow[];\n  isExpanded: boolean;\n  isCellSelected: boolean;\n  isRowSelected: boolean;\n  onRowSelectionChange: (checked: boolean) => void;\n  toggleGroup: () => void;\n}\n\nexport interface EditorProps<TValue, TRow = any, TSummaryRow = any> {\n  ref: React.Ref<Editor<{ [key: string]: TValue }>>;\n  column: CalculatedColumn<TRow, TSummaryRow>;\n  value: TValue;\n  row: TRow;\n  height: number;\n  onCommit: () => void;\n  onCommitCancel: () => void;\n  onOverrideKeyDown: (e: KeyboardEvent) => void;\n}\n\nexport interface SharedEditor2Props<TRow> {\n  row: Readonly<TRow>;\n  rowHeight: number;\n  onRowChange: (row: Readonly<TRow>, commitChanges?: boolean) => void;\n  onClose: (commitChanges?: boolean) => void;\n}\n\nexport interface Editor2Props<TRow, TSummaryRow = unknown> extends SharedEditor2Props<TRow> {\n  rowIdx: number;\n  column: Readonly<CalculatedColumn<TRow, TSummaryRow>>;\n  top: number;\n  left: number;\n  editorPortalTarget: Element;\n}\n\nexport interface HeaderRendererProps<TRow, TSummaryRow = unknown> {\n  column: CalculatedColumn<TRow, TSummaryRow>;\n  allRowsSelected: boolean;\n  onAllRowsSelectionChange: (checked: boolean) => void;\n}\n\nexport interface SharedEditorContainerProps {\n  firstEditorKeyPress: string | null;\n  scrollLeft: number;\n  scrollTop: number;\n  rowHeight: number;\n  onCommit: (e: CommitEvent) => void;\n  onCommitCancel: () => void;\n}\n\ninterface SelectedCellPropsBase {\n  idx: number;\n  onKeyDown: (event: React.KeyboardEvent<HTMLDivElement>) => void;\n}\n\nexport interface EditCellProps<TRow> extends SelectedCellPropsBase {\n  mode: 'EDIT';\n  editorPortalTarget: Element;\n  editorContainerProps: SharedEditorContainerProps;\n  editor2Props: SharedEditor2Props<TRow>;\n}\n\nexport interface SelectedCellProps extends SelectedCellPropsBase {\n  mode: 'SELECT';\n  onFocus: () => void;\n  dragHandleProps?: Pick<React.HTMLAttributes<HTMLDivElement>, 'onMouseDown' | 'onDoubleClick'>;\n}\n\nexport interface CellRendererProps<TRow, TSummaryRow = unknown> extends Omit<React.HTMLAttributes<HTMLDivElement>, 'style' | 'children'> {\n  rowIdx: number;\n  column: CalculatedColumn<TRow, TSummaryRow>;\n  row: TRow;\n  isCopied: boolean;\n  isDraggedOver: boolean;\n  isCellSelected: boolean;\n  isRowSelected: boolean;\n  eventBus: EventBus;\n  dragHandleProps?: Pick<React.HTMLAttributes<HTMLDivElement>, 'onMouseDown' | 'onDoubleClick'>;\n  onRowClick?: (rowIdx: number, row: TRow, column: CalculatedColumn<TRow, TSummaryRow>) => void;\n}\n\nexport interface RowRendererProps<TRow, TSummaryRow = unknown> extends Omit<React.HTMLAttributes<HTMLDivElement>, 'style' | 'children'> {\n  viewportColumns: readonly CalculatedColumn<TRow, TSummaryRow>[];\n  row: TRow;\n  cellRenderer?: React.ComponentType<CellRendererProps<TRow, TSummaryRow>>;\n  rowIdx: number;\n  copiedCellIdx?: number;\n  draggedOverCellIdx?: number;\n  isRowSelected: boolean;\n  eventBus: EventBus;\n  top: number;\n  selectedCellProps?: EditCellProps<TRow> | SelectedCellProps;\n  onRowClick?: (rowIdx: number, row: TRow, column: CalculatedColumn<TRow, TSummaryRow>) => void;\n  rowClass?: (row: TRow) => string | undefined;\n  setDraggedOverRowIdx?: (overRowIdx: number) => void;\n}\n\nexport interface GroupRowRendererProps<TRow, TSummaryRow = unknown> extends Omit<React.HTMLAttributes<HTMLDivElement>, 'style' | 'children'> {\n  id: string;\n  groupKey: unknown;\n  viewportColumns: readonly CalculatedColumn<TRow, TSummaryRow>[];\n  childRows: readonly TRow[];\n  rowIdx: number;\n  top: number;\n  level: number;\n  selectedCellIdx?: number;\n  isExpanded: boolean;\n  isRowSelected: boolean;\n  eventBus: EventBus;\n}\n\nexport interface FilterRendererProps<TRow, TFilterValue = unknown, TSummaryRow = unknown> {\n  column: CalculatedColumn<TRow, TSummaryRow>;\n  value: TFilterValue;\n  onChange: (value: TFilterValue) => void;\n}\n\nexport type Filters = Record<string, any>;\n\nexport interface CommitEvent<TUpdatedValue = never> {\n  cellKey: string;\n  rowIdx: number;\n  updated: TUpdatedValue;\n}\n\nexport interface RowsUpdateEvent<TUpdatedValue = never> {\n  cellKey: string;\n  fromRow: number;\n  toRow: number;\n  updated: TUpdatedValue;\n  action: UpdateActions;\n  fromCellKey?: string;\n}\n\nexport interface CheckCellIsEditableEvent<TRow, TSummaryRow> extends Position {\n  row: TRow;\n  column: CalculatedColumn<TRow, TSummaryRow>;\n}\n\nexport interface SelectRowEvent {\n  rowIdx: number;\n  checked: boolean;\n  isShiftClick: boolean;\n}\n\nexport type Dictionary<T> = Record<string, T>;\n\nexport type GroupByDictionary<TRow> = Dictionary<{\n  childRows: readonly TRow[];\n  childGroups: readonly TRow[] | GroupByDictionary<TRow>;\n  startRowIndex: number;\n}>;\n\nexport interface GroupRow<TRow> {\n  childRows: readonly TRow[];\n  id: string;\n  parentId: unknown;\n  groupKey: unknown;\n  isExpanded: boolean;\n  level: number;\n  posInSet: number;\n  setSize: number;\n  startRowIndex: number;\n}\n"]}