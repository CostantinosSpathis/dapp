{"version":3,"file":"columnUtils.js","sourceRoot":"","sources":["../../src/utils/columnUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { Column, CalculatedColumn, FormatterProps } from '../types';\nimport { ToggleGroupFormatter } from '../formatters';\nimport { SELECT_COLUMN_KEY } from '../Columns';\n\ninterface Metrics<R, SR> {\n  rawColumns: readonly Column<R, SR>[];\n  columnWidths: ReadonlyMap<string, number>;\n  minColumnWidth: number;\n  viewportWidth: number;\n  defaultResizable: boolean;\n  defaultSortable: boolean;\n  defaultFormatter: React.ComponentType<FormatterProps<R, SR>>;\n  rawGroupBy?: readonly string[];\n}\n\ninterface ColumnMetrics<TRow, TSummaryRow> {\n  columns: readonly CalculatedColumn<TRow, TSummaryRow>[];\n  lastFrozenColumnIndex: number;\n  totalFrozenColumnWidth: number;\n  totalColumnWidth: number;\n  groupBy: readonly string[];\n}\n\nexport function getColumnMetrics<R, SR>(metrics: Metrics<R, SR>): ColumnMetrics<R, SR> {\n  let left = 0;\n  let totalWidth = 0;\n  let allocatedWidths = 0;\n  let unassignedColumnsCount = 0;\n  let lastFrozenColumnIndex = -1;\n  type IntermediateColumn = Column<R, SR> & { width: number | undefined; rowGroup?: boolean };\n  let totalFrozenColumnWidth = 0;\n  const { rawGroupBy } = metrics;\n\n  const columns = metrics.rawColumns.map(metricsColumn => {\n    let width = getSpecifiedWidth(metricsColumn, metrics.columnWidths, metrics.viewportWidth);\n\n    if (width === undefined) {\n      unassignedColumnsCount++;\n    } else {\n      width = clampColumnWidth(width, metricsColumn, metrics.minColumnWidth);\n      allocatedWidths += width;\n    }\n\n    const column: IntermediateColumn = { ...metricsColumn, width };\n\n    if (rawGroupBy?.includes(column.key)) {\n      column.frozen = true;\n      column.rowGroup = true;\n    }\n\n    if (column.frozen) {\n      lastFrozenColumnIndex++;\n    }\n\n    return column;\n  });\n\n  columns.sort(({ key: aKey, frozen: frozenA }, { key: bKey, frozen: frozenB }) => {\n    // Sort select column first:\n    if (aKey === SELECT_COLUMN_KEY) return -1;\n    if (bKey === SELECT_COLUMN_KEY) return 1;\n\n    // Sort grouped columns second, following the groupBy order:\n    if (rawGroupBy?.includes(aKey)) {\n      if (rawGroupBy.includes(bKey)) {\n        return rawGroupBy.indexOf(aKey) - rawGroupBy.indexOf(bKey);\n      }\n      return -1;\n    }\n    if (rawGroupBy?.includes(bKey)) return 1;\n\n    // Sort frozen columns third:\n    if (frozenA) {\n      if (frozenB) return 0;\n      return -1;\n    }\n    if (frozenB) return 1;\n\n    // Sort other columns last:\n    return 0;\n  });\n\n  const unallocatedWidth = metrics.viewportWidth - allocatedWidths;\n  const unallocatedColumnWidth = Math.max(\n    Math.floor(unallocatedWidth / unassignedColumnsCount),\n    metrics.minColumnWidth\n  );\n\n  // Filter rawGroupBy and ignore keys that do not match the columns prop\n  const groupBy: string[] = [];\n  const calculatedColumns: CalculatedColumn<R, SR>[] = columns.map((column, idx) => {\n    // Every column should have a valid width as this stage\n    const width = column.width ?? clampColumnWidth(unallocatedColumnWidth, column, metrics.minColumnWidth);\n    const newColumn = {\n      ...column,\n      idx,\n      width,\n      left,\n      sortable: column.sortable ?? metrics.defaultSortable,\n      resizable: column.resizable ?? metrics.defaultResizable,\n      formatter: column.formatter ?? metrics.defaultFormatter\n    };\n\n    if (newColumn.rowGroup) {\n      groupBy.push(column.key);\n      newColumn.groupFormatter = column.groupFormatter ?? ToggleGroupFormatter;\n    }\n\n    totalWidth += width;\n    left += width;\n    return newColumn;\n  });\n\n  if (lastFrozenColumnIndex !== -1) {\n    const lastFrozenColumn = calculatedColumns[lastFrozenColumnIndex];\n    lastFrozenColumn.isLastFrozenColumn = true;\n    totalFrozenColumnWidth = lastFrozenColumn.left + lastFrozenColumn.width;\n  }\n\n  return {\n    columns: calculatedColumns,\n    lastFrozenColumnIndex,\n    totalFrozenColumnWidth,\n    totalColumnWidth: totalWidth,\n    groupBy\n  };\n}\n\nfunction getSpecifiedWidth<R, SR>(\n  { key, width }: Column<R, SR>,\n  columnWidths: ReadonlyMap<string, number>,\n  viewportWidth: number\n): number | undefined {\n  if (columnWidths.has(key)) {\n    // Use the resized width if available\n    return columnWidths.get(key);\n  }\n  if (typeof width === 'number') {\n    return width;\n  }\n  if (typeof width === 'string' && /^\\d+%$/.test(width)) {\n    return Math.floor(viewportWidth * parseInt(width, 10) / 100);\n  }\n  return undefined;\n}\n\nfunction clampColumnWidth<R, SR>(\n  width: number,\n  { minWidth, maxWidth }: Column<R, SR>,\n  minColumnWidth: number\n): number {\n  width = Math.max(width, minWidth ?? minColumnWidth);\n\n  if (typeof maxWidth === 'number') {\n    return Math.min(width, maxWidth);\n  }\n\n  return width;\n}\n\n// Logic extented to allow for functions to be passed down in column.editable\n// this allows us to decide whether we can be editing from a cell level\nexport function canEdit<R, SR>(column: Column<R, SR>, row: R): boolean {\n  if (typeof column.editable === 'function') {\n    return column.editable(row);\n  }\n  return Boolean(column.editor ?? column.editor2 ?? column.editable);\n}\n\nexport function getColumnScrollPosition<R, SR>(columns: readonly CalculatedColumn<R, SR>[], idx: number, currentScrollLeft: number, currentClientWidth: number): number {\n  let left = 0;\n  let frozen = 0;\n\n  for (let i = 0; i < idx; i++) {\n    const column = columns[i];\n    if (column) {\n      if (column.width) {\n        left += column.width;\n      }\n      if (column.frozen) {\n        frozen += column.width;\n      }\n    }\n  }\n\n  const selectedColumn = columns[idx];\n  if (selectedColumn) {\n    const scrollLeft = left - frozen - currentScrollLeft;\n    const scrollRight = left + selectedColumn.width - currentScrollLeft;\n\n    if (scrollLeft < 0) {\n      return scrollLeft;\n    }\n    if (scrollRight > currentClientWidth) {\n      return scrollRight - currentClientWidth;\n    }\n  }\n\n  return 0;\n}\n"]}