{"version":3,"file":"selectedCellUtils.js","sourceRoot":"","sources":["../../src/utils/selectedCellUtils.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,OAAO,EAAE,MAAM,eAAe,CAAC;AAWxC,MAAM,UAAU,sBAAsB,CAAQ,EAAE,gBAAgB,EAAE,OAAO,EAAE,IAAI,EAAE,qBAAqB,EAAE,UAAU,EAAqC;IACrJ,MAAM,MAAM,GAAG,OAAO,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC;IAC7C,MAAM,GAAG,GAAG,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC;IAC1C,IAAI,MAAM,CAAC,QAAQ,KAAK,IAAI,IAAI,UAAU,CAAC,GAAG,CAAC;QAAE,OAAO,KAAK,CAAC;IAC9D,MAAM,cAAc,GAAG,qBAAqB,CAAC,CAAC,CAAC,qBAAqB,CAAC,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,gBAAgB,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;IAClH,OAAO,cAAc,IAAI,OAAO,CAAQ,MAAM,EAAE,GAAG,CAAC,CAAC;AACvD,CAAC;AASD,MAAM,UAAU,2BAA2B,CAAQ,EAAE,kBAAkB,EAAE,OAAO,EAAE,SAAS,EAAE,YAAY,EAA0C;IACjJ,IAAI,kBAAkB,KAAK,MAAM,EAAE;QACjC,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,YAAY,CAAC;QACrC,MAAM,YAAY,GAAG,OAAO,CAAC,MAAM,CAAC;QACpC,MAAM,iBAAiB,GAAG,GAAG,KAAK,YAAY,CAAC;QAC/C,MAAM,mBAAmB,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC;QAEvC,IAAI,iBAAiB,EAAE;YACrB,IAAI,kBAAkB,KAAK,YAAY,EAAE;gBACvC,MAAM,SAAS,GAAG,MAAM,KAAK,SAAS,GAAG,CAAC,CAAC;gBAC3C,IAAI,CAAC,SAAS,EAAE;oBACd,OAAO;wBACL,GAAG,EAAE,CAAC;wBACN,MAAM,EAAE,MAAM,GAAG,CAAC;qBACnB,CAAC;iBACH;aACF;iBAAM,IAAI,kBAAkB,KAAK,eAAe,EAAE;gBACjD,OAAO;oBACL,MAAM;oBACN,GAAG,EAAE,CAAC;iBACP,CAAC;aACH;SACF;aAAM,IAAI,mBAAmB,EAAE;YAC9B,IAAI,kBAAkB,KAAK,YAAY,EAAE;gBACvC,MAAM,UAAU,GAAG,MAAM,KAAK,CAAC,CAAC;gBAChC,IAAI,CAAC,UAAU,EAAE;oBACf,OAAO;wBACL,MAAM,EAAE,MAAM,GAAG,CAAC;wBAClB,GAAG,EAAE,YAAY,GAAG,CAAC;qBACtB,CAAC;iBACH;aACF;iBAAM,IAAI,kBAAkB,KAAK,eAAe,EAAE;gBACjD,OAAO;oBACL,MAAM;oBACN,GAAG,EAAE,YAAY,GAAG,CAAC;iBACtB,CAAC;aACH;SACF;KACF;IAED,OAAO,YAAY,CAAC;AACtB,CAAC;AAUD,MAAM,UAAU,WAAW,CAAQ,EAAE,kBAAkB,EAAE,OAAO,EAAE,SAAS,EAAE,gBAAgB,EAAE,EAAE,MAAM,EAAE,GAAG,EAAE,EAAE,QAAQ,EAA0B;IAChJ,8HAA8H;IAC9H,0GAA0G;IAC1G,IAAI,kBAAkB,KAAK,MAAM,IAAI,kBAAkB,KAAK,YAAY,EAAE;QACxE,MAAM,eAAe,GAAG,GAAG,KAAK,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC;QACnD,MAAM,gBAAgB,GAAG,GAAG,KAAK,CAAC,CAAC;QACnC,MAAM,SAAS,GAAG,MAAM,KAAK,SAAS,GAAG,CAAC,CAAC;QAC3C,MAAM,UAAU,GAAG,MAAM,KAAK,CAAC,CAAC;QAEhC,OAAO,QAAQ,CAAC,CAAC,CAAC,gBAAgB,IAAI,UAAU,CAAC,CAAC,CAAC,eAAe,IAAI,SAAS,CAAC;KACjF;IAED,OAAO,KAAK,CAAC;AACf,CAAC","sourcesContent":["import { CellNavigationMode } from '../enums';\nimport { canEdit } from './columnUtils';\nimport { CalculatedColumn, Position, GroupRow } from '../types';\n\ninterface IsSelectedCellEditableOpts<R, SR> {\n  selectedPosition: Position;\n  columns: readonly CalculatedColumn<R, SR>[];\n  rows: readonly (R | GroupRow<R>)[];\n  onCheckCellIsEditable?: (arg: { row: R; column: CalculatedColumn<R, SR> } & Position) => boolean;\n  isGroupRow: (row: R | GroupRow<R>) => row is GroupRow<R>;\n}\n\nexport function isSelectedCellEditable<R, SR>({ selectedPosition, columns, rows, onCheckCellIsEditable, isGroupRow }: IsSelectedCellEditableOpts<R, SR>): boolean {\n  const column = columns[selectedPosition.idx];\n  const row = rows[selectedPosition.rowIdx];\n  if (column.rowGroup === true || isGroupRow(row)) return false;\n  const isCellEditable = onCheckCellIsEditable ? onCheckCellIsEditable({ row, column, ...selectedPosition }) : true;\n  return isCellEditable && canEdit<R, SR>(column, row);\n}\n\ninterface GetNextSelectedCellPositionOpts<R, SR> {\n  cellNavigationMode: CellNavigationMode;\n  columns: readonly CalculatedColumn<R, SR>[];\n  rowsCount: number;\n  nextPosition: Position;\n}\n\nexport function getNextSelectedCellPosition<R, SR>({ cellNavigationMode, columns, rowsCount, nextPosition }: GetNextSelectedCellPositionOpts<R, SR>): Position {\n  if (cellNavigationMode !== 'NONE') {\n    const { idx, rowIdx } = nextPosition;\n    const columnsCount = columns.length;\n    const isAfterLastColumn = idx === columnsCount;\n    const isBeforeFirstColumn = idx === -1;\n\n    if (isAfterLastColumn) {\n      if (cellNavigationMode === 'CHANGE_ROW') {\n        const isLastRow = rowIdx === rowsCount - 1;\n        if (!isLastRow) {\n          return {\n            idx: 0,\n            rowIdx: rowIdx + 1\n          };\n        }\n      } else if (cellNavigationMode === 'LOOP_OVER_ROW') {\n        return {\n          rowIdx,\n          idx: 0\n        };\n      }\n    } else if (isBeforeFirstColumn) {\n      if (cellNavigationMode === 'CHANGE_ROW') {\n        const isFirstRow = rowIdx === 0;\n        if (!isFirstRow) {\n          return {\n            rowIdx: rowIdx - 1,\n            idx: columnsCount - 1\n          };\n        }\n      } else if (cellNavigationMode === 'LOOP_OVER_ROW') {\n        return {\n          rowIdx,\n          idx: columnsCount - 1\n        };\n      }\n    }\n  }\n\n  return nextPosition;\n}\n\ninterface CanExitGridOpts<R, SR> {\n  cellNavigationMode: CellNavigationMode;\n  columns: readonly CalculatedColumn<R, SR>[];\n  rowsCount: number;\n  selectedPosition: Position;\n  shiftKey: boolean;\n}\n\nexport function canExitGrid<R, SR>({ cellNavigationMode, columns, rowsCount, selectedPosition: { rowIdx, idx }, shiftKey }: CanExitGridOpts<R, SR>): boolean {\n  // When the cellNavigationMode is 'none' or 'changeRow', you can exit the grid if you're at the first or last cell of the grid\n  // When the cellNavigationMode is 'loopOverRow', there is no logical exit point so you can't exit the grid\n  if (cellNavigationMode === 'NONE' || cellNavigationMode === 'CHANGE_ROW') {\n    const atLastCellInRow = idx === columns.length - 1;\n    const atFirstCellInRow = idx === 0;\n    const atLastRow = rowIdx === rowsCount - 1;\n    const atFirstRow = rowIdx === 0;\n\n    return shiftKey ? atFirstCellInRow && atFirstRow : atLastCellInRow && atLastRow;\n  }\n\n  return false;\n}\n"]}