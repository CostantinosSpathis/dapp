{"version":3,"file":"useClickOutside.js","sourceRoot":"","sources":["../../src/hooks/useClickOutside.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,EAAE,SAAS,EAAE,MAAM,OAAO,CAAC;AAE1C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA+CG;AAEH,MAAM,UAAU,eAAe,CAAC,OAAmB;IACjD,MAAM,gBAAgB,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;IACvC,0EAA0E;IAC1E,oEAAoE;IACpE,qEAAqE;IACrE,MAAM,UAAU,GAAG,MAAM,CAAC,GAAS,EAAE;QACnC,MAAM,IAAI,KAAK,CAAC,+CAA+C,CAAC,CAAC;IACnE,CAAC,CAAC,CAAC;IAEH,SAAS,CAAC,GAAG,EAAE;QACb,UAAU,CAAC,OAAO,GAAG,OAAO,CAAC;IAC/B,CAAC,CAAC,CAAC;IAEH,SAAS,CAAC,GAAG,EAAE;QACb,IAAI,qBAAyC,CAAC;QAE9C,SAAS,2BAA2B;YAClC,IAAI,OAAO,qBAAqB,KAAK,QAAQ,EAAE;gBAC7C,oBAAoB,CAAC,qBAAqB,CAAC,CAAC;gBAC5C,qBAAqB,GAAG,SAAS,CAAC;aACnC;QACH,CAAC;QAED,SAAS,iBAAiB;YACxB,qBAAqB,GAAG,SAAS,CAAC;YAElC,IAAI,gBAAgB,CAAC,OAAO,EAAE;gBAC5B,gBAAgB,CAAC,OAAO,GAAG,KAAK,CAAC;aAClC;iBAAM;gBACL,UAAU,CAAC,OAAO,EAAE,CAAC;aACtB;QACH,CAAC;QAED,SAAS,wBAAwB;YAC/B,2BAA2B,EAAE,CAAC;YAC9B,gBAAgB,CAAC,OAAO,GAAG,KAAK,CAAC;YACjC,qBAAqB,GAAG,qBAAqB,CAAC,iBAAiB,CAAC,CAAC;QACnE,CAAC;QAED,MAAM,CAAC,gBAAgB,CAAC,OAAO,EAAE,wBAAwB,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC;QAE9E,OAAO,GAAG,EAAE;YACV,MAAM,CAAC,mBAAmB,CAAC,OAAO,EAAE,wBAAwB,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC;YACjF,2BAA2B,EAAE,CAAC;QAChC,CAAC,CAAC;IACJ,CAAC,EAAE,EAAE,CAAC,CAAC;IAEP,OAAO,SAAS,cAAc;QAC5B,gBAAgB,CAAC,OAAO,GAAG,IAAI,CAAC;IAClC,CAAC,CAAC;AACJ,CAAC","sourcesContent":["import { useRef, useEffect } from 'react';\n\n/**\n * Detecting outside click on a react component is surprisingly hard.\n * A general approach is to have a global click handler on the document\n * which checks if the click target is inside the editor container or\n * not using editorContainer.contains(e.target). This approach works well\n * until portals are used for editors. Portals render children into a DOM\n * node that exists outside the DOM hierarchy of the parent component so\n * editorContainer.contains(e.target) does not work. Here are some examples\n * of the DOM structure with different types of editors\n *\n *\n * SimpleEditor for example Texbox (No Portals)\n *   <div data-grid>..</div>\n *   <div portal-created-by-the-grid-for-editors>\n *      <div editor-container>\n *        <div simple-editor>..</div>\n *      </div>\n *   </div>\n *\n * ComplexEditor for example Modals (using Portals)\n *   <div data-grid>..</div>\n *   <div portal-created-by-the-grid-for-editors>\n *      <div editor-container>\n *        // Nothing here\n *      </div>\n *   </div>\n *   <div portal-created-by-the-editor>\n *     <div complex-editor>..</div>\n *   </div>\n *\n *\n * One approach to detect outside click is to use synthetic event bubbling through\n * portals. An event fired from inside a portal will propagate to ancestors\n * in the containing React tree, even if those elements are not ancestors\n * in the DOM tree. This means a click handler can be attached on the window\n * and on the editor container. The editor container can set a flag to notify\n * that the click was inside the editor and the window click handler can use\n * this flag to call onClickOutside. This approach however has a few caveats\n * - Click handler on the window is set using window.addEventListener\n * - Click handler on the editor container is set using onClick prop\n *\n * This means if a child component inside the editor calls e.stopPropagation\n * then the click handler on the editor container will not be called whereas\n * the document click handler will be called.\n * https://github.com/facebook/react/issues/12518\n *\n * To solve this issue onClickCapture event is used.\n */\n\nexport function useClickOutside(onClick: () => void) {\n  const clickedInsideRef = useRef(false);\n  // We need to prevent the `useEffect` from cleaning up between re-renders,\n  // as `handleDocumentClick` might otherwise miss valid click events.\n  // To that end we instead access the latest `onClick` prop via a ref.\n  const onClickRef = useRef((): void => {\n    throw new Error('Cannot call an event handler while rendering.');\n  });\n\n  useEffect(() => {\n    onClickRef.current = onClick;\n  });\n\n  useEffect(() => {\n    let animationFrameRequest: number | undefined;\n\n    function cancelAnimationFrameRequest() {\n      if (typeof animationFrameRequest === 'number') {\n        cancelAnimationFrame(animationFrameRequest);\n        animationFrameRequest = undefined;\n      }\n    }\n\n    function checkOutsideClick() {\n      animationFrameRequest = undefined;\n\n      if (clickedInsideRef.current) {\n        clickedInsideRef.current = false;\n      } else {\n        onClickRef.current();\n      }\n    }\n\n    function handleWindowCaptureClick() {\n      cancelAnimationFrameRequest();\n      clickedInsideRef.current = false;\n      animationFrameRequest = requestAnimationFrame(checkOutsideClick);\n    }\n\n    window.addEventListener('click', handleWindowCaptureClick, { capture: true });\n\n    return () => {\n      window.removeEventListener('click', handleWindowCaptureClick, { capture: true });\n      cancelAnimationFrameRequest();\n    };\n  }, []);\n\n  return function onClickCapture() {\n    clickedInsideRef.current = true;\n  };\n}\n"]}