{"version":3,"file":"useViewportColumns.js","sourceRoot":"","sources":["../../src/hooks/useViewportColumns.ts"],"names":[],"mappings":"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","sourcesContent":["import { useMemo } from 'react';\n\nimport { CalculatedColumn, Column } from '../types';\nimport { getColumnMetrics } from '../utils';\nimport { DataGridProps } from '../DataGrid';\nimport { ValueFormatter } from '../formatters';\n\ntype SharedDataGridProps<R, K extends keyof R, SR> = Pick<DataGridProps<R, K, SR>,\n  | 'defaultColumnOptions'\n  | 'rowGrouper'\n>;\n\ninterface ViewportColumnsArgs<R, K extends keyof R, SR> extends SharedDataGridProps<R, K, SR> {\n  rawColumns: readonly Column<R, SR>[];\n  rawGroupBy?: readonly string[];\n  viewportWidth: number;\n  scrollLeft: number;\n  columnWidths: ReadonlyMap<string, number>;\n}\n\nexport function useViewportColumns<R, K extends keyof R, SR>({\n  rawColumns,\n  columnWidths,\n  viewportWidth,\n  scrollLeft,\n  defaultColumnOptions,\n  rawGroupBy,\n  rowGrouper\n}: ViewportColumnsArgs<R, K, SR>) {\n  const minColumnWidth = defaultColumnOptions?.minWidth ?? 80;\n  const defaultFormatter = defaultColumnOptions?.formatter ?? ValueFormatter;\n  const defaultSortable = defaultColumnOptions?.sortable ?? false;\n  const defaultResizable = defaultColumnOptions?.resizable ?? false;\n\n  const { columns, lastFrozenColumnIndex, totalColumnWidth, totalFrozenColumnWidth, groupBy } = useMemo(() => {\n    return getColumnMetrics<R, SR>({\n      rawColumns,\n      minColumnWidth,\n      viewportWidth,\n      columnWidths,\n      defaultSortable,\n      defaultResizable,\n      defaultFormatter,\n      rawGroupBy: rowGrouper ? rawGroupBy : undefined\n    });\n  }, [columnWidths, defaultFormatter, defaultResizable, defaultSortable, minColumnWidth, rawColumns, rawGroupBy, rowGrouper, viewportWidth]);\n\n  const [colOverscanStartIdx, colOverscanEndIdx] = useMemo((): [number, number] => {\n    // get the viewport's left side and right side positions for non-frozen columns\n    const viewportLeft = scrollLeft + totalFrozenColumnWidth;\n    const viewportRight = scrollLeft + viewportWidth;\n    // get first and last non-frozen column indexes\n    const lastColIdx = columns.length - 1;\n    const firstUnfrozenColumnIdx = Math.min(lastFrozenColumnIndex + 1, lastColIdx);\n\n    // skip rendering non-frozen columns if the frozen columns cover the entire viewport\n    if (viewportLeft >= viewportRight) {\n      return [firstUnfrozenColumnIdx, firstUnfrozenColumnIdx];\n    }\n\n    // get the first visible non-frozen column index\n    let colVisibleStartIdx = firstUnfrozenColumnIdx;\n    while (colVisibleStartIdx < lastColIdx) {\n      const { left, width } = columns[colVisibleStartIdx];\n      // if the right side of the columnn is beyond the left side of the available viewport,\n      // then it is the first column that's at least partially visible\n      if (left + width > viewportLeft) {\n        break;\n      }\n      colVisibleStartIdx++;\n    }\n\n    // get the last visible non-frozen column index\n    let colVisibleEndIdx = colVisibleStartIdx;\n    while (colVisibleEndIdx < lastColIdx) {\n      const { left, width } = columns[colVisibleEndIdx];\n      // if the right side of the column is beyond or equal to the right side of the available viewport,\n      // then it the last column that's at least partially visible, as the previous column's right side is not beyond the viewport.\n      if (left + width >= viewportRight) {\n        break;\n      }\n      colVisibleEndIdx++;\n    }\n\n    const colOverscanStartIdx = Math.max(firstUnfrozenColumnIdx, colVisibleStartIdx - 1);\n    const colOverscanEndIdx = Math.min(lastColIdx, colVisibleEndIdx + 1);\n\n    return [colOverscanStartIdx, colOverscanEndIdx];\n  }, [columns, lastFrozenColumnIndex, scrollLeft, totalFrozenColumnWidth, viewportWidth]);\n\n  const viewportColumns = useMemo((): readonly CalculatedColumn<R, SR>[] => {\n    const viewportColumns: CalculatedColumn<R, SR>[] = [];\n    for (let colIdx = 0; colIdx <= colOverscanEndIdx; colIdx++) {\n      const column = columns[colIdx];\n\n      if (colIdx < colOverscanStartIdx && !column.frozen) continue;\n      viewportColumns.push(column);\n    }\n\n    return viewportColumns;\n  }, [colOverscanEndIdx, colOverscanStartIdx, columns]);\n\n  return { columns, viewportColumns, totalColumnWidth, lastFrozenColumnIndex, totalFrozenColumnWidth, groupBy };\n}\n"]}